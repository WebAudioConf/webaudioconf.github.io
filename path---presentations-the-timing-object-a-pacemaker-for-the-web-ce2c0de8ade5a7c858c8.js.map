{"version":3,"sources":["webpack:///path---presentations-the-timing-object-a-pacemaker-for-the-web-ce2c0de8ade5a7c858c8.js","webpack:///./.cache/json/presentations-the-timing-object-a-pacemaker-for-the-web.json"],"names":["webpackJsonp","482","module","exports","pathContext","abstract","authors","link","name","slug","title","type"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,SAAA,g+DAAAC,UAAu/DC,KAAA,4BAAAC,KAAA,wBAAgEC,KAAA,4CAAAC,MAAA,8CAAAC,KAAA","file":"path---presentations-the-timing-object-a-pacemaker-for-the-web-ce2c0de8ade5a7c858c8.js","sourcesContent":["webpackJsonp([158052232471885],{\n\n/***/ 482:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"abstract\":\"The web knows many different timing mechanisms which all have their unique use case. Unfortunately there is no easy way to align any of those timers. They often have their own timeline, unit and level of accuracy. How would you for example synchronize a slide show on a beamer with the audio recording of the speaker played back on a different device?\\n\\nThe Timing Object is aiming to solve that problem. It is a W3C Draft which introduces yet another timing mechanism. But it is completely unopinionated about what it controls. It is specifically designed to control multiple timed sources in sync.\\n\\nSadly the Timing Object hasn't gained much traction so far. No browser vendor has implemented it yet or is currently planning to do so. The specification process itself seems to be slowing down as well. But that doesn't have to be the end of the story. The Timing Object can mostly be implemented in user land and some parts of the spec are purposefully incomplete to allow different implementations by third party vendors. I want to show what is already possible and how everybody can start using the Timing Object right now in their applications. As many of the presentations and demos at previous WACs have shown, many people have built their own custom solution to realize distributed synchronization. I hope to raise interest in the Timing Object Draft and motivate more people to contribute their experience to the standardization process.\\n\\nOne of the things which is meant to be implemented by third party vendors is the TimingProvider. The TimingProvider is responsible for synchronizing Timing Objects across different devices. I want to demonstrate the usage of a TimingProvider which uses WebRTC internally to setup the communication between participating devices.\\n\\nThere are of course also some parts of the specification which have to be build by browser vendors. But I'm sure that if the Timing Object gets used in the wild the browser vendors will eventually start to implement it natively.\",\"authors\":[{\"link\":\"http://media-codings.com/\",\"name\":\"Christoph Guttandin\"}],\"slug\":\"the-timing-object-a-pacemaker-for-the-web\",\"title\":\"The Timing Object - A Pacemaker for the Web\",\"type\":\"talk\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---presentations-the-timing-object-a-pacemaker-for-the-web-ce2c0de8ade5a7c858c8.js","module.exports = {\"pathContext\":{\"abstract\":\"The web knows many different timing mechanisms which all have their unique use case. Unfortunately there is no easy way to align any of those timers. They often have their own timeline, unit and level of accuracy. How would you for example synchronize a slide show on a beamer with the audio recording of the speaker played back on a different device?\\n\\nThe Timing Object is aiming to solve that problem. It is a W3C Draft which introduces yet another timing mechanism. But it is completely unopinionated about what it controls. It is specifically designed to control multiple timed sources in sync.\\n\\nSadly the Timing Object hasn't gained much traction so far. No browser vendor has implemented it yet or is currently planning to do so. The specification process itself seems to be slowing down as well. But that doesn't have to be the end of the story. The Timing Object can mostly be implemented in user land and some parts of the spec are purposefully incomplete to allow different implementations by third party vendors. I want to show what is already possible and how everybody can start using the Timing Object right now in their applications. As many of the presentations and demos at previous WACs have shown, many people have built their own custom solution to realize distributed synchronization. I hope to raise interest in the Timing Object Draft and motivate more people to contribute their experience to the standardization process.\\n\\nOne of the things which is meant to be implemented by third party vendors is the TimingProvider. The TimingProvider is responsible for synchronizing Timing Objects across different devices. I want to demonstrate the usage of a TimingProvider which uses WebRTC internally to setup the communication between participating devices.\\n\\nThere are of course also some parts of the specification which have to be build by browser vendors. But I'm sure that if the Timing Object gets used in the wild the browser vendors will eventually start to implement it natively.\",\"authors\":[{\"link\":\"http://media-codings.com/\",\"name\":\"Christoph Guttandin\"}],\"slug\":\"the-timing-object-a-pacemaker-for-the-web\",\"title\":\"The Timing Object - A Pacemaker for the Web\",\"type\":\"talk\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/presentations-the-timing-object-a-pacemaker-for-the-web.json\n// module id = 482\n// module chunks = 158052232471885"],"sourceRoot":""}