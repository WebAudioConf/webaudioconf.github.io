{"version":3,"sources":["webpack:///path---presentations-latency-and-synchronization-in-web-audio-6c5011a28463aae0ddce.js","webpack:///./.cache/json/presentations-latency-and-synchronization-in-web-audio.json"],"names":["webpackJsonp","476","module","exports","pathContext","abstract","authors","link","name","slug","title","type"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,SAAA,qjCAAAC,UAA4kCC,KAAA,6BAAAC,KAAA,qBAA8DC,KAAA,2CAAAC,MAAA,2CAAAC,KAAA","file":"path---presentations-latency-and-synchronization-in-web-audio-6c5011a28463aae0ddce.js","sourcesContent":["webpackJsonp([208834088707970],{\n\n/***/ 476:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"abstract\":\"The recording and playback of audio on a computer is always subject to latency and Web Audio applications are no different. Latency makes it difficult to write software that properly synchronizes computer audio with “real world” audio and interactions. In many situations, Web Audio apps have to deal with huge amounts of latency.\\nHumans have issues with timing too: it’s often hard for us to perform actions perfectly on rhythm or in synchrony with our computer’s understanding of time.\\nIn this talk, I’ll detail the techniques I used to develop a live-looping app using Web Audio, including methods for measuring and handling various types of latency and structuring code to avoid spreading latency-handling logic throughout the application.\\nI’ll also discuss features that help humans more easily express timing in music, like allowing a loop to start before the “record” button was pressed and implementing button press “fudging” that starts, stops, and records loops at the time the performer meant to press the button, not the time they actually pressed the button.\",\"authors\":[{\"link\":\"https://www.resonator.app/\",\"name\":\"Walker Henderson\"}],\"slug\":\"latency-and-synchronization-in-web-audio\",\"title\":\"Latency and Synchronization in Web Audio\",\"type\":\"talk\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---presentations-latency-and-synchronization-in-web-audio-6c5011a28463aae0ddce.js","module.exports = {\"pathContext\":{\"abstract\":\"The recording and playback of audio on a computer is always subject to latency and Web Audio applications are no different. Latency makes it difficult to write software that properly synchronizes computer audio with “real world” audio and interactions. In many situations, Web Audio apps have to deal with huge amounts of latency.\\nHumans have issues with timing too: it’s often hard for us to perform actions perfectly on rhythm or in synchrony with our computer’s understanding of time.\\nIn this talk, I’ll detail the techniques I used to develop a live-looping app using Web Audio, including methods for measuring and handling various types of latency and structuring code to avoid spreading latency-handling logic throughout the application.\\nI’ll also discuss features that help humans more easily express timing in music, like allowing a loop to start before the “record” button was pressed and implementing button press “fudging” that starts, stops, and records loops at the time the performer meant to press the button, not the time they actually pressed the button.\",\"authors\":[{\"link\":\"https://www.resonator.app/\",\"name\":\"Walker Henderson\"}],\"slug\":\"latency-and-synchronization-in-web-audio\",\"title\":\"Latency and Synchronization in Web Audio\",\"type\":\"talk\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/presentations-latency-and-synchronization-in-web-audio.json\n// module id = 476\n// module chunks = 208834088707970"],"sourceRoot":""}